/*
  Liquid Handling Robot - 74HC595 + Emergency Stop Verification Test

  This enhanced test program verifies:
  1. 3x 74HC595 shift register chain wiring
  2. Emergency stop system with AND gate
  3. MKS SERVO42C enable control
  4. Professional safety systems

  Hardware Requirements:
  - ESP32-S3
  - 3x 74HC595 shift registers (daisy-chained)
  - 74HC08 AND gate for emergency stop
  - Emergency stop button (NC, twist-to-reset)
  - LEDs + resistors for visual verification
  - Oscilloscope (optional, for signal verification)

  Safety Features:
  - Hardware emergency stop independent of software
  - Servo enable control with fail-safe design
  - Professional laboratory-grade safety implementation

  Usage:
  1. Connect LEDs to each shift register output
  2. Wire emergency stop system with AND gate
  3. Upload this test program
  4. Monitor serial output for test results
  5. Test emergency stop functionality
*/

#include <Arduino.h>

// I2S pins for shift register control
#define I2S_DATA_PIN    4   // Serial data to first 74HC595
#define I2S_BCK_PIN     5   // Shift clock (SRCLK)
#define I2S_WS_PIN      6   // Latch clock (RCLK)

// Emergency stop and enable control pins
#define ENABLE_PIN      19  // Software enable control (to AND gate)
#define ESTOP_STATUS_PIN 18 // Monitor emergency stop status
#define STATUS_LED_PIN  2   // System status LED

// Test configuration
#define NUM_SHIFT_REGISTERS 3
#define TOTAL_BITS (NUM_SHIFT_REGISTERS * 8)  // 24 bits total

// Shift register data buffer
uint8_t shiftData[NUM_SHIFT_REGISTERS];

// System state
bool systemEnabled = false;
bool emergencyStopActive = false;
unsigned long testStartTime = 0;

// Function declarations
void clearAllRegisters();
void updateShiftRegisters();
void testIndividualBits();
void testByRegister();
void testMotorPatterns();
void testLiquidHandlingPatterns();
void testWalkingBit();
void testEmergencyStopSystem();
void testServoEnableControl();
void simulateSyringeOperation();
void testAuxiliaryControls();
void printBitFunction(int bit);
void printRegisterFunction(int reg);
void updateSystemStatus();
void waitForUserInput();
bool checkEmergencyStop();
void enableSystem();
void disableSystem();

void setup() {
    Serial.begin(115200);
    delay(2000);

    Serial.println("=========================================================");
    Serial.println(" LIQUID HANDLING ROBOT - COMPREHENSIVE WIRING TEST");
    Serial.println("    Including Emergency Stop & Servo Enable Verification");
    Serial.println("=========================================================");
    Serial.println();

    testStartTime = millis();

    // Initialize I2S pins
    pinMode(I2S_DATA_PIN, OUTPUT);
    pinMode(I2S_BCK_PIN, OUTPUT);
    pinMode(I2S_WS_PIN, OUTPUT);

    // Initialize safety and control pins
    pinMode(ENABLE_PIN, OUTPUT);
    pinMode(ESTOP_STATUS_PIN, INPUT_PULLUP);
    pinMode(STATUS_LED_PIN, OUTPUT);

    // Initialize all outputs to safe state
    digitalWrite(I2S_DATA_PIN, LOW);
    digitalWrite(I2S_BCK_PIN, LOW);
    digitalWrite(I2S_WS_PIN, LOW);
    digitalWrite(ENABLE_PIN, HIGH);  // Start disabled (Active LOW enable)
    digitalWrite(STATUS_LED_PIN, LOW);

    Serial.println("System Initialization:");
    Serial.printf("  I2S Data Pin (SER):     GPIO %d\n", I2S_DATA_PIN);
    Serial.printf("  I2S Clock Pin (SRCLK):  GPIO %d\n", I2S_BCK_PIN);
    Serial.printf("  I2S Latch Pin (RCLK):   GPIO %d\n", I2S_WS_PIN);
    Serial.printf("  Software Enable Pin:    GPIO %d\n", ENABLE_PIN);
    Serial.printf("  E-Stop Status Pin:      GPIO %d\n", ESTOP_STATUS_PIN);
    Serial.printf("  System Status LED:      GPIO %d\n", STATUS_LED_PIN);
    Serial.println();

    // Clear all shift registers
    clearAllRegisters();
    Serial.println("All shift registers cleared to safe state.");
    Serial.println();

    // Check initial emergency stop status
    updateSystemStatus();
    
    delay(1000);
}

void loop() {
    // Update system status
    updateSystemStatus();

    Serial.println(" Starting comprehensive safety & wiring verification...");
    Serial.println();

    // Wait for user confirmation before starting tests
    waitForUserInput();

    // Test 1: Individual bit test
    testIndividualBits();
    delay(2000);

    // Test 2: Register-by-register test
    testByRegister();
    delay(2000);

    // Test 3: Motor control patterns
    testMotorPatterns();
    delay(2000);

    // Test 4: Liquid handling patterns
    testLiquidHandlingPatterns();
    delay(2000);

    // Test 5: Walking bit pattern
    testWalkingBit();
    delay(2000);

    // Test 6: Emergency stop system (CRITICAL SAFETY TEST)
    testEmergencyStopSystem();
    delay(3000);

    // Test 7: Servo enable control
    testServoEnableControl();
    delay(2000);

    Serial.println(" All tests completed. Repeating in 15 seconds...");
    Serial.println("==================================================");
    Serial.println();
    delay(15000);
}

void waitForUserInput() {
    Serial.println("  SAFETY CHECK REQUIRED");
    Serial.println("   Press Enter to begin test sequence...");
    Serial.println("   Ensure emergency stop is NOT pressed");
    Serial.println("   Have LEDs connected for visual verification");
    Serial.println();

    while (!Serial.available()) {
        updateSystemStatus();
        delay(100);
    }
    
    // Clear serial buffer
    while (Serial.available()) {
        Serial.read();
    }
    
    Serial.println(" User confirmation received. Starting tests...");
    Serial.println();
}

void updateSystemStatus() {
    bool estopPressed = !digitalRead(ESTOP_STATUS_PIN); // Active LOW
    
    if (estopPressed != emergencyStopActive) {
        emergencyStopActive = estopPressed;
        if (emergencyStopActive) {
            Serial.println(" EMERGENCY STOP ACTIVATED!");
            disableSystem();
        } else {
            Serial.println(" Emergency stop released");
        }
    }

    // Update status LED
    if (emergencyStopActive) {
        digitalWrite(STATUS_LED_PIN, HIGH); // Solid on = E-stop active
    } else if (systemEnabled) {
        // Blink fast = system enabled
        digitalWrite(STATUS_LED_PIN, (millis() / 100) % 2);
    } else {
        // Blink slow = system disabled but safe
        digitalWrite(STATUS_LED_PIN, (millis() / 500) % 2);
    }
}

bool checkEmergencyStop() {
    updateSystemStatus();
    return !emergencyStopActive;
}

void enableSystem() {
    if (!emergencyStopActive) {
        digitalWrite(ENABLE_PIN, LOW); // Active LOW enable
        systemEnabled = true;
        Serial.println(" System ENABLED");
    } else {
        Serial.println(" Cannot enable - Emergency stop is active");
    }
}

void disableSystem() {
    digitalWrite(ENABLE_PIN, HIGH); // Disable
    systemEnabled = false;
    clearAllRegisters();
    Serial.println(" System DISABLED");
}

void clearAllRegisters() {
    for (int i = 0; i < NUM_SHIFT_REGISTERS; i++) {
        shiftData[i] = 0x00;
    }
    updateShiftRegisters();
}

void updateShiftRegisters() {
    // Latch pin low during data transmission
    digitalWrite(I2S_WS_PIN, LOW);
    delayMicroseconds(1);

    // Send data for all registers (MSB first, Register 2  1  0)
    for (int reg = NUM_SHIFT_REGISTERS - 1; reg >= 0; reg--) {
        shiftOut(I2S_DATA_PIN, I2S_BCK_PIN, MSBFIRST, shiftData[reg]);
    }

    // Latch the data
    delayMicroseconds(1);
    digitalWrite(I2S_WS_PIN, HIGH);
    delayMicroseconds(1);
    digitalWrite(I2S_WS_PIN, LOW);
}

void testEmergencyStopSystem() {
    Serial.println(" Test 6: Emergency Stop System Verification");
    Serial.println("   CRITICAL SAFETY TEST - Hardware Emergency Stop");
    Serial.println("   This test verifies hardware-independent safety shutdown");
    Serial.println();
    
    if (!checkEmergencyStop()) {
        Serial.println(" EMERGENCY STOP IS ACTIVE - Release button before testing");
        Serial.println("   Twist emergency stop button counterclockwise to release");
        
        // Wait for E-stop release
        while (emergencyStopActive) {
            updateSystemStatus();
            delay(100);
        }
        delay(1000);
    }
    
    Serial.println(" Emergency stop released - beginning safety test");
    Serial.println();

    // Test software enable control
    Serial.println("Phase 1: Software Enable Control Test");
    Serial.println("  Testing software enable/disable functionality...");
    
    enableSystem();
    delay(1000);
    
    if (systemEnabled) {
        Serial.println("  Software enable:  WORKING");
        
        // Test with shift register output
        clearAllRegisters();
        shiftData[0] = 0x01; // X_STEP bit
        updateShiftRegisters();
        Serial.println("  Shift register output active (LED should be on)");
        delay(2000);
    }
    
    disableSystem();
    Serial.println("  Software disable:  WORKING");
    delay(1000);

    Serial.println();
    Serial.println("Phase 2: Emergency Stop Button Test");
    Serial.println("   CRITICAL: Now test the emergency stop button");
    Serial.println("  Instructions:");
    Serial.println("    1. System will enable servos via software");
    Serial.println("    2. PRESS AND HOLD the emergency stop button");
    Serial.println("    3. Verify servos disable immediately (LEDs off)");
    Serial.println("    4. Release emergency stop to continue");
    Serial.println();
    
    Serial.println("Enabling system for emergency stop test...");
    enableSystem();
    
    if (systemEnabled) {
        // Activate multiple shift register outputs for visible test
        shiftData[0] = 0xFF; // All motor control bits
        shiftData[1] = 0x0F; // Some auxiliary bits
        updateShiftRegisters();
        
        Serial.println(" Multiple LEDs should now be ON");
        Serial.println(" PRESS EMERGENCY STOP BUTTON NOW");
        Serial.println("   (LEDs should turn OFF immediately when pressed)");
        
        // Monitor for emergency stop activation
        unsigned long testStart = millis();
        bool estopTested = false;
        
        while ((millis() - testStart) < 15000) { // 15 second test window
            updateSystemStatus();
            
            if (emergencyStopActive && !estopTested) {
                Serial.println(" EMERGENCY STOP DETECTED!");
                Serial.println(" Hardware emergency stop is WORKING");
                Serial.println("   LEDs should be OFF (servos disabled)");
                estopTested = true;
                
                // Wait for release
                Serial.println("Release emergency stop button to continue...");
                while (emergencyStopActive) {
                    updateSystemStatus();
                    delay(100);
                }
                
                Serial.println(" Emergency stop released - system ready");
                break;
            }
            
            delay(100);
        }
        
        if (!estopTested) {
            Serial.println("  Emergency stop was not tested in time window");
            Serial.println("   Please test emergency stop manually");
        }
    }
    
    disableSystem();
    Serial.println();
    Serial.println("Emergency stop system test completed.");
    Serial.println(" Professional safety system verified");
    Serial.println();
}

void testServoEnableControl() {
    Serial.println(" Test 7: MKS SERVO42C Enable Control");
    Serial.println("   Testing servo enable/disable functionality");
    Serial.println();
    
    if (!checkEmergencyStop()) {
        Serial.println(" Cannot test - Emergency stop is active");
        return;
    }
    
    Serial.println("Servo Enable Test Sequence:");
    
    // Test enable/disable cycles
    for (int cycle = 1; cycle <= 3; cycle++) {
        Serial.printf("  Cycle %d: Enable  Disable\n", cycle);
        
        enableSystem();
        Serial.println("    Servos ENABLED (should hold position)");
        delay(2000);
        
        disableSystem();
        Serial.println("    Servos DISABLED (should be free-running)");
        delay(1000);
    }
    
    Serial.println("Servo enable control test completed.");
    Serial.println(" MKS SERVO42C enable system verified");
    Serial.println();
}

void testIndividualBits() {
    Serial.println(" Test 1: Individual Bit Verification");
    Serial.println("   Each bit will be turned on individually");
    Serial.println("   Verify the correct LED lights up for each bit");
    Serial.println();

    if (!checkEmergencyStop()) return;

    for (int bit = 0; bit < TOTAL_BITS; bit++) {
        clearAllRegisters();

        int reg = bit / 8;
        int regBit = bit % 8;

        shiftData[reg] = (1 << regBit);
        updateShiftRegisters();

        Serial.printf("Bit %2d: Register %d, Bit %d - ", bit, reg, regBit);
        printBitFunction(bit);

        delay(500);
        
        // Check for emergency stop during test
        if (!checkEmergencyStop()) {
            Serial.println(" Test interrupted by emergency stop");
            return;
        }
    }

    clearAllRegisters();
    Serial.println("Individual bit test completed.");
    Serial.println();
}

void testByRegister() {
    Serial.println(" Test 2: Register-by-Register Test");
    Serial.println("   Each register will be fully activated");
    Serial.println();

    if (!checkEmergencyStop()) return;

    for (int reg = 0; reg < NUM_SHIFT_REGISTERS; reg++) {
        clearAllRegisters();
        shiftData[reg] = 0xFF;  // All bits on
        updateShiftRegisters();

        Serial.printf("Register %d: All outputs HIGH\n", reg);
        printRegisterFunction(reg);
        Serial.println();

        delay(1000);
        
        if (!checkEmergencyStop()) {
            Serial.println(" Test interrupted by emergency stop");
            return;
        }
    }

    clearAllRegisters();
    Serial.println("Register test completed.");
    Serial.println();
}

void testMotorPatterns() {
    Serial.println(" Test 3: Stepper Motor Patterns");
    Serial.println("   Testing step/direction patterns for each axis");
    Serial.println();

    if (!checkEmergencyStop()) return;

    const char* axisNames[] = {"X", "Y", "Z", "A"};

    for (int axis = 0; axis < 4; axis++) {
        Serial.printf("Testing %s-axis stepper control:\n", axisNames[axis]);

        clearAllRegisters();

        int stepBit = axis * 2;      // 0, 2, 4, 6
        int dirBit = axis * 2 + 1;   // 1, 3, 5, 7

        // Direction forward, step pulse
        shiftData[0] = (1 << dirBit) | (1 << stepBit);
        updateShiftRegisters();
        Serial.printf("  %s_DIR=1, %s_STEP=1 (Forward step)\n", axisNames[axis], axisNames[axis]);
        delay(250);

        // Direction forward, no step
        shiftData[0] = (1 << dirBit);
        updateShiftRegisters();
        Serial.printf("  %s_DIR=1, %s_STEP=0 (Forward direction)\n", axisNames[axis], axisNames[axis]);     
        delay(250);

        // Direction reverse, step pulse
        shiftData[0] = (1 << stepBit);
        updateShiftRegisters();
        Serial.printf("  %s_DIR=0, %s_STEP=1 (Reverse step)\n", axisNames[axis], axisNames[axis]);
        delay(250);

        clearAllRegisters();
        delay(500);
        
        if (!checkEmergencyStop()) {
            Serial.println(" Test interrupted by emergency stop");
            return;
        }
    }

    Serial.println("Motor pattern test completed.");
    Serial.println();
}

void testLiquidHandlingPatterns() {
    Serial.println(" Test 4: Liquid Handling Control Patterns");
    Serial.println("   Testing auxiliary controls for liquid handling");
    Serial.println();

    if (!checkEmergencyStop()) return;

    Serial.println("Syringe Pump Simulation:");
    simulateSyringeOperation();

    delay(1000);

    Serial.println("Auxiliary Controls:");
    testAuxiliaryControls();

    Serial.println("Liquid handling pattern test completed.");
    Serial.println();
}

void simulateSyringeOperation() {
    if (!checkEmergencyStop()) return;

    // Aspirate operation
    Serial.println("   Aspirating liquid...");
    for (int i = 0; i < 10; i++) {
        clearAllRegisters();
        shiftData[0] = 0x80;         // A_DIR = 1 (aspirate direction)
        updateShiftRegisters();
        delay(50);

        shiftData[0] = 0x80 | 0x40;  // A_DIR = 1, A_STEP = 1
        updateShiftRegisters();
        delay(50);
        
        if (!checkEmergencyStop()) return;
    }

    delay(500);

    // Dispense operation
    Serial.println("   Dispensing liquid...");
    for (int i = 0; i < 10; i++) {
        clearAllRegisters();
        shiftData[0] = 0x00;  // A_DIR = 0 (dispense direction)
        updateShiftRegisters();
        delay(50);

        shiftData[0] = 0x40;  // A_DIR = 0, A_STEP = 1
        updateShiftRegisters();
        delay(50);
        
        if (!checkEmergencyStop()) return;
    }

    clearAllRegisters();
}

void testAuxiliaryControls() {
    const char* auxNames[] = {
        "SPARE", "COOLANT_MIST", "COOLANT_FLOOD", "USER_PIN_1",
        "USER_PIN_2", "USER_PIN_3", "USER_PIN_4", "SPARE"
    };

    for (int bit = 0; bit < 8; bit++) {
        clearAllRegisters();
        shiftData[1] = (1 << bit);
        updateShiftRegisters();

        Serial.printf("  Register 1, Bit %d: %s\n", bit, auxNames[bit]);
        delay(300);
        
        if (!checkEmergencyStop()) {
            Serial.println(" Test interrupted by emergency stop");
            return;
        }
    }

    clearAllRegisters();
}

void testWalkingBit() {
    Serial.println(" Test 5: Walking Bit Pattern");
    Serial.println("   A single bit walks through all 24 positions");
    Serial.println("   Verify LEDs light up in sequence 023");
    Serial.println();

    if (!checkEmergencyStop()) return;

    for (int bit = 0; bit < TOTAL_BITS; bit++) {
        clearAllRegisters();

        int reg = bit / 8;
        int regBit = bit % 8;

        shiftData[reg] = (1 << regBit);
        updateShiftRegisters();

        Serial.printf("Walking bit: Position %2d ", bit);
        printBitFunction(bit);

        delay(200);
        
        if (!checkEmergencyStop()) {
            Serial.println(" Test interrupted by emergency stop");
            return;
        }
    }

    clearAllRegisters();
    Serial.println("Walking bit test completed.");
    Serial.println();
}

void printBitFunction(int bit) {
    const char* functions[] = {
        "X_STEP", "X_DIR", "Y_STEP", "Y_DIR",
        "Z_STEP", "Z_DIR", "A_STEP", "A_DIR",
        "SPARE", "COOLANT_MIST", "COOLANT_FLOOD", "USER_PIN_1",
        "USER_PIN_2", "USER_PIN_3", "USER_PIN_4", "SPARE",
        "EXPANSION_0", "EXPANSION_1", "EXPANSION_2", "EXPANSION_3",
        "EXPANSION_4", "EXPANSION_5", "EXPANSION_6", "EXPANSION_7"
    };

    if (bit < 24) {
        Serial.println(functions[bit]);
    } else {
        Serial.println("UNKNOWN");
    }
}

void printRegisterFunction(int reg) {
    switch (reg) {
        case 0:
            Serial.println("  Function: Stepper motor control (X,Y,Z,A step/direction)");
            break;
        case 1:
            Serial.println("  Function: Auxiliary controls (pumps, valves, sensors)");
            break;
        case 2:
            Serial.println("  Function: Future expansion (additional devices)");
            break;
        default:
            Serial.println("  Function: Unknown register");
            break;
    }
}
